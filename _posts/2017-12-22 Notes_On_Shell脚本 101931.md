## [linux中shell变量\$#,\$@,\$0,\$1,\$2的含义解释](http://www.cnblogs.com/fhefh/archive/2011/04/15/2017613.html)

```bash
# arg parse and env check {{{
while getopts "f:a:h" arg #选项后面的冒号表示该选项需要参数
do
		case $arg in
			 f )
                GIT_CONFIG=${OPTARG}
				;; #;;相当于break
			 a )
				ProcessOptionA ${OPTARG}
				;;
			 h )
				OmuShowHelp
                exit 0
				;;
			* )
				OmuShowHelp
				exit 1
				;;
		esac
done

```

[local\export\declare\set](http://www.cnblogs.com/itcomputer/p/5008164.html)

shell 脚本中中定义的变量不加local时默认是global变量；

export 定义与修改环境变量，相当于定义同一shell环境下，不同脚本之间交互的变量；

```bash
export [-fnp][变量名称]=[变量设置值]
```

> #   -f 　代表[变量名称]中为函数名称。　  
>
> #   -n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。　 
>
> #    -p 　列出所有的shell赋予程序的环境变量。



# Linux 指令篇：系统设置--declare  和set类似

**功能说明：**声明 shell 变量。
**语　　法：**declare [+/-][rxi][变量名称＝设置值] 或 declare -f
**补充说明：**declare为shell指令，在第一种语法中可用来声明变量并设置变量的属性([rix]即为变量的属性），在第二种语法中可用来显示shell函数。若不加上任何参数，则会显示全部的shell变量与函数(与执行set指令的效果相同)。
**参　　数：**
　+/- 　"-"可用来指定变量的属性，"+"则是取消变量所设的属性。 
　-f 　仅显示函数。 
　r 　将变量设置为只读。 
　x 　指定的变量会成为环境变量，可供shell以外的程序来使用。 
　i 　[设置值]可以是数值，字符串或运算式。

```bash
#! /bin/bash

#!/bin/bash
interval=10
coreNum=`cat /proc/stat | grep cpu[0-9] -c`
date_stamp=$(date +%Y%m%d%H%M%S)
processName=""


while getopts "i:c:p:" arg
do
	case $arg in
		i)
		interval=${OPTARG}
		echo -e "\n \033[93m Set record interval : ${interval}s \033[0m:"
		;;
		c)
		coreNum=${OPTARG}
		echo -e "\n \033[93m CPU processor Num : ${coreNum} \033[0m:"
		;;
		p)
		pid=${OPTARG}
		echo -e "\n \033[93m Set pid : ${pid} \033[0m:"
		;;
		*)
		echo -e "\n \033[93m Wrong param!! \033[0m:"
		exit 1
		;;
	esac		
done
LOG_FILE=${HOME}/${date_stamp}_${processName}_proc_memlog.csv

echo -n "TIME_________________," >>${LOG_FILE}
echo -n "MemCost(kB)," >> ${LOG_FILE}
echo -n "CUPCost(%)" >> ${LOG_FILE}
echo "">>${LOG_FILE}

#pid=`pidof processName`    ##获得该进程的进程ID号
echo $pid                 ##ID号输出到终端界面
interval=1               ## 每隔十秒钟记录一次
  while true              
  do
    echo -n "$(date +"%y-%m-%d %H:%M:%S")," >> ${LOG_FILE}    #获取系统当时时间   
    VMRss=`cat /proc/$pid/status|grep -e VmRSS|sed 's/.*://g'|cut -d k -f 1 ` ##将内存占用率VmRSS写入目录/home/user/share/test/下的文件proc_memlog.txt中。proc_memlog.txt为自动生成的文件。">>"符号为追加写入，写入的内容不会被覆盖
    VMRss=$[VMRss]
    #'scale=2;${VMRss}/1024'|bc >>${LOG_FILE}
    #VMRss=$("scale=2;${VMRss}/1024"|bc)
    echo -n $VMRss >> ${LOG_FILE}
    cpu=`top -n 1 -p $pid|tail -3|head -1|awk '{print $10}'` ##获得该进程的CPU使用率。
    cpu="scale=2;${cpu}/${coreNum}"|bc
    echo -n ",$cpu" >> ${LOG_FILE}     ##将CPU使用率写入proc_memlog.txt文件中
    echo "" >> ${LOG_FILE}       ##将一个空白行写入proc_memlog.txt文件中
    sleep $interval
 done #写CSV文件
```

[cut 命令](http://www.cnblogs.com/dong008259/archive/2011/12/09/2282679.html)

```
CUT(1)                           User Commands                          CUT(1)

NAME
       cut - remove sections from each line of files

SYNOPSIS
       cut OPTION... [FILE]...

DESCRIPTION
       Print selected parts of lines from each FILE to standard output.

       Mandatory  arguments  to  long  options are mandatory for short options
       too.

       -b, --bytes=LIST
              select only these bytes

       -c, --characters=LIST
              select only these characters

       -d, --delimiter=DELIM
              use DELIM instead of TAB for field delimiter

       -f, --fields=LIST
              select only these fields;  also print any line that contains  no
              delimiter character, unless the -s option is specified

       -n     (ignored)

       --complement
              complement the set of selected bytes, characters or fields

       -s, --only-delimited
              do not print lines not containing delimiters


```





[awk](http://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html)

[百度百科](https://baike.baidu.com/item/Awk)里提供了更详细的介绍

```bash
GAWK(1)                                                 Utility Commands                                                 GAWK(1)

NAME
       gawk - pattern scanning and processing language

SYNOPSIS
       gawk [ POSIX or GNU style options ] -f program-file [ -- ] file ...
       gawk [ POSIX or GNU style options ] [ -- ] program-text file ...

       pgawk [ POSIX or GNU style options ] -f program-file [ -- ] file ...
       pgawk [ POSIX or GNU style options ] [ -- ] program-text file ...

       dgawk [ POSIX or GNU style options ] -f program-file [ -- ] file ...


```

### 内置变量介绍

awk提供了有很多内置变量，如果你经常使用awk处理文本，了解这些这些内置变量的使用是很有必要的。下面看一下这些内置变量的详细介绍。

ARGC[命令行参数](https://baike.baidu.com/item/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0)个数（不包括awk的选项和awk的程序内容）。

ARGIND 当前正在处理的ARGV中的文件的索引值（同时处理多个文件时会用到）。

ARGV 命令行参数序列[数组](https://baike.baidu.com/item/%E6%95%B0%E7%BB%84)，下标从0开始。

CONVFMT 数字转换格式，和C语言中的数字输出格式化类似，默认为"%.6g"。

ENVIRON 当前系统的环境变量。

ERRNO 出错时的错误信息。

FIELDWIDTHS 以空格分隔的字段宽度，如果指定此变量，awk将会用指定的宽度替换变量FS指定的[分隔符](https://baike.baidu.com/item/%E5%88%86%E9%9A%94%E7%AC%A6)。看下面的例子：

[LinuxSong@test /tmp]$ cat t

abcdefasfa

abcdefasfa

abcdefasfa

[LinuxSong@test /tmp]$ awk 'BEGIN {FIELDWIDTHS="2 3 4"}{print $1,$2,$3}' t

ab cde fasf

ab cde fasf

ab cde fasf

FILENAME 当前正在处理的文件名，该变量不能在BEGIN块中使用。

[FNR](https://baike.baidu.com/item/FNR)当前处理的记录号。

FS 字段的[分隔符](https://baike.baidu.com/item/%E5%88%86%E9%9A%94%E7%AC%A6)，默认为空格。

IGNORECASE 如果该变量设置为非0值，在进行[字符串匹配](https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D)时忽略大小写。

NF 当前记录中的字段个数。

NR 已经读出的记录数。

OFMT 数字的输出格式。

OFS 输出的字段分隔符，默认为空格。

ORS 输出的记录分隔符，默认为新行。

RS 输入记录的[分隔符](https://baike.baidu.com/item/%E5%88%86%E9%9A%94%E7%AC%A6)，默认为新行。

RSTART 被match（）函数匹配的字符串的起始位置，如果没有匹配则为0（从1开始）。

RLENGTH 被match（）函数匹配的字符串的长度。

SUBSEP[数组](https://baike.baidu.com/item/%E6%95%B0%E7%BB%84)中多个下标的分隔符，默认为"\034"。

#### 内置函数

awk 之所以成为一种优秀的[程序设计语言](https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80)的原因之一是它吸收了某些优秀的程序设计语言（例如C）语言的许多优点。这些优点之一就是内置函数的使用，awk定义并支持了一系列的内置函数，由于这些函数的使用，使得awk提供的功能更为完善和强大，例如，awk使用了一系列的字符串处理内置函数(这些函数看起来与C 语言的字符串处理函数相似，其使用方式与C语言中的函数也相差无几)，正是由于这些内置函数的使用，使awk处理字符串的功能更加强大。本文后面的附录中列有一般的awk所提供的内置函数，这些内置函数也许与你的awk版本有些出入，因此，在使用之前，最好参考一下你的系统中的联机帮助。

内置的字符串函数

| gsub(r,s)       | 在整个$0中用s代替r          |
| --------------- | -------------------- |
| gsub(r,s,t)     | 在整个t中用s替代r           |
| index(s,t)      | 返回s中字符串t的第一位置        |
| length(s)       | 返回s长度                |
| match(s,r)      | 测试s是否包含匹配r的字符串       |
| split(s,a,fs)   | 在fs上将s分成序列a          |
| sprint(fmt,exp) | 返回经fmt格式化后的exp       |
| sub(r,s)        | 用$0中最左边最长的子串代替s      |
| substr(s,p)     | 返回字符串s中从p开始的后缀部分     |
| substr(s,p,n)   | 返回字符串s中从p开始长度为n的后缀部分 |

gsub函数有点类似于sed查找和替换。它允许替换一个字符串或字符为另一个字符串或字符，并以[正则表达式](https://baike.baidu.com/item/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)的形式执行。第一个函数作用于记录$0，第二个gsub函数允许指定目标，然而，如果未指定目标，缺省为$0。

index(s，t）函数返回目标字符串s中查询字符串t的首位置。length函数返回[字符](https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6)串s字符长度。

match函数测试字符串s是否包含一个正则表达式r定义的匹配。

split使用域[分隔符](https://baike.baidu.com/item/%E5%88%86%E9%9A%94%E7%AC%A6)fs将字符串s划分为指定序列a。

sprint函数类似于printf函数，返回基本输出格式fmt的结果字符串exp。

sub(r，s）函数将用s替代$0中最左边最长的子串，该子串被r匹配。

substr(s，p）返回字符串s在位置p后的后缀。

substr(s，p，n）同上，并指定子串长度为n。



### [sed指令](http://www.cnblogs.com/dong008259/archive/2011/12/07/2279897.html)

```sed
SED(1)                                                    User Commands                                                   SED(1)

NAME
       sed - stream editor for filtering and transforming text

SYNOPSIS
       sed [OPTION]... {script-only-if-no-other-script} [input-file]...

DESCRIPTION
       Sed  is  a  stream  editor.   A stream editor is used to perform basic text transformations on an input stream (a file or
       input from a pipeline).  While in some ways similar to an editor which permits scripted edits (such as ed), sed works  by
       making  only one pass over the input(s), and is consequently more efficient.  But it is sed's ability to filter text in a
       pipeline which particularly distinguishes it from other types of editors.

       -n, --quiet, --silent

              suppress automatic printing of pattern space

       -e script, --expression=script

              add the script to the commands to be executed

       -f script-file, --file=script-file

              add the contents of script-file to the commands to be executed

       --follow-symlinks

              follow symlinks when processing in place

       -i[SUFFIX], --in-place[=SUFFIX]

              edit files in place (makes backup if SUFFIX supplied)

       -l N, --line-length=N

              specify the desired line-wrap length for the `l' command

```



>### [linux shell 括号总结](http://www.baidu.com/link?url=FI5_AEEoAkQfCMX0IvhObMoNEPw8Da-X1uaprcMOustksgjWf3D0r5hFuowxhcn-wt7dF0wEsvWsEe3TG69YQPVXTU58flQUcoEqRFE3QYG&wd=&eqid=f81784e700002786000000025a44c806)
>
>

```
在这里我想说的是几种shell里的小括号,大括号结构和有括号的变量，命令的用法，如下：

1.${var}
2.$(cmd)
3.()和{}
4.${var:-string},${var:+string},${var:=string},${var:?string}
5.$((exp))
6.$(var%pattern),$(var%%pattern),$(var#pattern),$(var##pattern)

现在分述如下：


1.Shell中变量的原形：${var}
大家常见的变量形式都是$var,如

$ var=test
$ echo $var
test

但当你要显示变量值加随意的字符(我这里用AA)时，就会出错，如下：

$ echo $varAA

$

这时应该用变量的原形：${var}，即是加一个大括号来限定变量名称的范围，如下
$ echo ${var}AA
testAA
$

以这个特性，我们可以很方便地写一个批量改后缀名的程序，我把它命名为mymv，程序如下：
#!/bin/bash

tail=$1
for filename in `ls`
do
mv $filename ${filename}.$tail
done

程序需要提供一个后缀名，如c，表示改为后缀为c的C程序文件，看下面的测试：
$ ls
a b c
$ mymv c
$ ls
a.c b.c c.c
$

看样子程序运行的很好，但这是不完善的程序，有2个要注意的问题：
A,目录下没有子目录，如果有一个目录，假设为dir，则也会被改为dir.c，这显然不是我们想要的，应该修正这个程序能识别目录。
B,没有帮助对程序的参数进行处理，程序应该足够友好，在用户没有给定后缀名时应能处理，像上面的将直接给文件加上了一个点(.),这显然也不是我们想要的。

因为我们的目的是说明${var}，这样已经足够了，因此这里不会再对上面的程序进行修正。

2.命令替换$(cmd)
命令替换$(cmd)和符号`cmd`(注意这不是单引号，在美式键盘上，`是ESC下面的那个键)有相同之处
$ ls
a b c
$ echo $(ls)
a b c
$ echo `ls`
a b c

我们来分析一下命令echo $(ls)，以便理解所谓命令替换是什么意思：
shell扫描一遍命令行，发现了$(cmd)结构，便将$(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令echo $(ls)中的$(ls)位置，即替换了$(ls),再执行echo命令。
如下：
echo $(ls)被替换成了echo a b c
这里要注意的是$(cmd)中的命令的错误输出是不会被替换的，替换的只是标准输出：
$ var=$(cat d) ###文件d在当前目录不存在
cat: d: 没有那个文件或目录
$ echo $var

$ ###显然var变量的值是空的

3、一串的命令执行()和{}
()和{}都是对一串的命令进行执行，但有所区别：
A,()只是对一串命令重新开一个子shell进行执行
B,{}对一串命令在当前shell执行
C,()和{}都是把一串的命令放在括号里面，并且命令之间用;号隔开
D,()最后一个命令可以不用分号
E,{}最后一个命令要用分号
F,{}的第一个命令和左括号之间必须要有一个空格
G,()里的各命令不必和括号有空格
H,()和{}中括号里面的某个命令的重定向只影响该命令，但括号外的重定向则影响到括号里的所有命令

我们来看几个例子：
$ var=test
$ (var=notest; echo $var) ###变量var值为notest，此是在子shell中有效
notest
$ echo $var ###父shell中值仍为test
test
$ { var=notest; echo $var;} ###注意左括号和var之间要有一个空格
notest
$ echo $var ###父shell中的var变量的值变为了notest
notest
$ { var1=test1;var2=test2;echo $var1>a;echo $var2;} ###输出test1被重定向到文件a中，
test2 ###而test2输出则仍输出到标准输出中。
$ cat a
test1
$ { var1=test1;var2=test2;echo $var1;echo $var2;}>a ###括号内命令的标准输出全部被重定向到文件a中
$ cat a
test1
test2

下面是一个脚步例子：

(
    echo "1"
    echo "2"
) | awk '{print NR,$0}'

4,几种特殊的替换结构：${var:-string},${var:+string},${var:=string},${var:?string}
A,${var:-string}和${var:=string}
若变量var为空，则用在命令行中用string来替换${var:-string}，否则变量var不为空时，则用变量var的值来替换${var:-string}
如：
$ echo $newvar

$ echo ${newvar:-a}
a
$ echo $newvar ###变量newvar的值仍然是空，但上一命令行中${newvar:-a}被替换成了a

$ newvar=b
$ echo ${newvar:-a} ###变量newvar的值不为空时，此命令行中的${newvar:-b}被替换为$newvar，即b
b
$

对于${var:=string}的替换规则和${var:-string}是一样的，所不同之处是${var:=string}若var为空时，用string替换${var:=string}的同时，把string赋给变量var：


$ echo $newvar

$ echo ${newvar:=a}
a
$ echo $newvar ###变量newvar被赋值为a，同时${newvar:=a}被替换成a
a
$ echo ${newvar:=b} ###变量newvar不为空(其值已被赋为a)，则${newvar:=b}被替换为newvar的值(即b)
a
$ echo $newvar
a

${var:=string}很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。
如设置默认的编辑器：
PHP 代码:
echo You use editor: ${EDITOR:=/bin/vi}

B,${var:+string}
${var:+string}的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的)
$ echo $newvar
a
$ echo ${newvar:+b}
b
$ echo $newvar
a
$ newvar=
$ echo ${newvar:+b}

$

C,${var:?string}
替换规则为：若变量var不为空，则用变量var的值来替换${var:?string}；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。
$ newvar=
$ echo ${newvar:?没有设置newvar的值}
bash: newvar: 没有设置newvar的值
$ newvar=a
$ echo ${newvar:?没有设置newvar的值}
a
$

补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。
$ echo ${var:-`date`}
日 3月 6 02:10:39 CST 2005
$ echo ${var:-$(date)}
日 3月 6 02:11:46 CST 2005
$ a=test
$ echo ${var:-$a}
test
$

5.POSIX标准的扩展计算:$((exp))
这种计算是符合C语言的运算符，也就是说只要符合C的运算符都可用在$((exp))，甚至是三目运算符。
注意：这种扩展计算是整数型的计算，不支持浮点型.若是逻辑判断，表达式exp为真则为1,假则为0。
$ echo $((3+2))
5
$ echo $((3>2))
1
$ echo $((25<3 ? 2:3))
3
$ echo $var

$ echo $((var=2+3))
5
$ echo $var
5
$ echo $((var++))
5
$ echo $var
6
$

好了，上面的例子足够了，这也表明了这种扩展运算是很强大的。

6.四种模式匹配替换结构：${var%pattern},${var%%pattern},${var#pattern},${var##pattern}
这四种结构的意义是：${var%pattern}和${var%%pattern}表示从最右边(即结尾)匹配的，${var#pattern} 和${var##pattern}从最左边(即开头)匹配的。其中${var%pattern}和${var#pattern}是最短匹 配，${var%%pattern}和${var##pattern}是最长匹配。只有在pattern中使用了通配符才能有最长最短的匹配，否则没有最 长最短匹配之分。

结构中的pattern支持通配符，*表示零个或多个任意字符，?表示零个或一个任意字符，[...]表示匹配中括号里面的字符，[!...]表示不匹配中括号里面的字符。
$ var=aabbbccbbdbb
$ echo ${var%b}
aabbbccbbdb
$ echo ${var%%b}
aabbbccbbdb
$ echo ${var#a}
abbbccbbdbb
$ echo ${var##a}
abbbccbbdbb
$ echo ${var%*b}
aabbbccbbdb
$ echo ${var%%*b}

$ echo ${var#a*}
abbbccbbdbb
$ echo ${var##a*}

$

上面是简单的例举四种模式匹配替换结构的用法。

•其他（见man bash中的Parameter Expansion)

${parameter/pattern/string}
              Pattern substitution.  The pattern is expanded to produce a pat‐
              tern  just  as in pathname expansion.  Parameter is expanded and
              the longest match of pattern against its value is replaced  with
              string.   If  pattern  begins with /, all matches of pattern are
              replaced  with  string.   Normally  only  the  first  match   is
              replaced.  If pattern begins with #, it must match at the begin‐
              ning of the expanded value of parameter.  If pattern begins with
              %,  it must match at the end of the expanded value of parameter.
              If string is null, matches of pattern are deleted and the / fol‐
              lowing pattern may be omitted.  If parameter is @ or *, the sub‐
              stitution operation is applied to each positional  parameter  in
              turn,  and the expansion is the resultant list.  If parameter is
              an array variable subscripted with  @  or  *,  the  substitution
              operation  is  applied  to each member of the array in turn, and
              the expansion is the resultant list.

(( )) ：一对圆括号有两个地方用到。

1，for循环，

for (( expr1 ; expr2 ; expr3 ))

这里一对双括号里边的表达式，GNU的文档指出，expr1支持 Shell Arithmetic；expr2不为0时，expr3被赋值且语句执行。说的很麻烦，还要花时间搞清楚什么是Shell Arithmetic。其实一言以蔽之，支持数字条件。比如：

for (( a=0 ; a<10 ; a++ )); do echo $a; done

会输出 0 1 2 3 （带换行哦~~~）

2，数学表达

(( )) 和 $(( ))

(( )) 的用法与let一样，就不用多解释了吧~~~

$(( ))就是把计算结果拿出来，可以用在双引号里边，比如：

echo "1+2=$(( 1 + 2 ))"

会输出 1+2=3

( )：一个圆括号

在for循环里，跟C语法一样一样的。

或者是子程序，返回整个里边表达的返回值。里边的变量都是局部的，修改不会带到外边。举例子

a=1

(a=3; echo $a)

echo a

结果是 3 1

还有个就是圈数组。。。这个就没神马意思了

[ ]：一个方括号，是bash的命令，查man手册是可以查到的，跟test一样，在手册里可以看到很多用法。比如-b -c -gt -eq 什么的很多，还有用-a表示与，-o表示或等等

[[ ]]：一对方括号是一个方括号的加强版，则是Shell的保留字，里边支持了 || && 等等这些符号。一般我喜欢用这个

还有相对复杂的 { }

几个用处，区分变量，如：

var=abcd; echo ${var}EFG;

这样，Bash就不会认为变量是varEFG了

还有用来截取字符串的 ${ }语法比较灵活多变，这里不做多解释，大家有兴趣可以自己去搜搜资料，一般我脚本用到的字符串处理，这个都能搞定了。

代码块。用来区分代码的，但是跟( )有个区别，就是在末尾要加上 ;

1．()

在子shell中运行
(a=1);echo $a，结果是空，因为a=1不是在当前shell中运行的(a=1);(echo $a)也是空的。不在同一个子shell中
数组的赋值，见最后的补充

2.(())

表达式计算
a=1;((a++)); echo $a，这时a就是2了。

3.<()和>()

进程代入，可以把命令的执行结果当成文件一样读入
比如comm前一般需要sort，那就可以这样comm <(sort 1.lst) <(sort 2.lst)
或者是paste <(cut -t2 file1) <(cut -t1 file1)
，和管道差不多，但是支持多个输入。

4.$()

$(cmd) 执行cmd的结果，比如cmd是echo ls，那么就是执行ls，比如file$(which bash)，which bash的结果是/bin/bash，所以file $(which bash)等于file /bin/bash。如果你$(ls)，而且你的当前目录下只有a b两个文件，那么就是执行a b，然后系统会提示，命令没找到。

5.$(())

表达式扩展，和(())很相似，但是这个是有点不同，$(())不能直接$((b++))，b=1;echo $((++b))这时b等于2，显示的也是2，b=1;echo $((b++))这时b等于2，显示的是1.

6.[]和[[]]

[]就是 test，[]和[[]]都是条件表达式，不过[[]]有比[]高的容错性，如果a为空，那么[ $a -eq 0 ]会报错，但是[[ $a -eq 0 ]]不会，所以一般都会使用[[]]或者是[ "$a" -eq 0 ]，[[]]支持的功能也比[]多，比如[[ aaa =~a{3} ]]，
[] 还有一种用途，如果你的当前目录下有a1-a9九个文件，你可以用a[1-9]来替代这九个文件。有点需要注意，你不能用a[1-20]来代替a1- a20，必须要a[1-9] a1[0-9] a20。

7.$[]

$(())的过去形式，现在已经不建议使用

8.{}

{1..30} 就是1-30，或者是/{,s}bin/表示/bin/和/sbin/，ab{c,d,e}表示abc、abd、abe

9.${}

变量，用法很多，可以查看man bash。
先写这些，以后想到再补充吧。

补充：()同时也是数组的赋值，比如a=(1 3 5)，那么${a[0]}=1;${a[1]}=3;${a[2]}=5，需要注意的是，下标是从0开始的

Shell中的括号有其特殊的用法, 现总结如下:

1. 符号$后的括号

${a} 变量a的值, 在不引起歧义的情况下可以省略大括号.
$(cmd) 命令替换, 结果为shell命令cmd的输出, 和`cmd`效果相同, 不过某些Shell版本不支持$()形式的命令替换, 如tcsh.
$((exp)) 和`expr exp`效果相同, 计算数学表达式exp的数值, 其中exp只要符合C语言的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算.

2. 多条命令执行

(cmd1;cmd2;cmd3) 新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号.
{ cmd1;cmd2;cmd3;} 在当前shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后必须有分号, 第一条命令和左括号之间必须用空格隔开.
对{}和()而言, 括号中的重定向符只影响该条命令, 而括号外的重定向符影响到括号中的所有命令.

3. 双括号的特殊用法

(()) 增强括号的用法, 常用于算术运算比较. 双括号中的变量可以不使用$符号前缀, 只要括号中的表达式符合C语言运算规则, 支持多个表达式用逗号分开.
比如可以直接使用for((i=0;i<5;i++)), 如果不使用双括号, 则为for i in `seq 0 4`或者for i in {0..4}.
再如可以直接使用if (($i<5)), 如果不使用双括号, 则为if [ $i -lt 5 ].
[[]] 增强方括号用法, 常用于字符串的比较. 主要用于条件测试, 双括号中的表达式可以使用&&, ||, <, >等C语言语法.
比如可以直接使用if [[ $a != 1 && $a != 2 ]], 如果不适用双括号, 则为if [ $a -ne 1] && [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ].
```

### [tar命令详解](http://man.linuxde.net/tar)

```
压　缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称
查　询：tar -jtv -f filename.tar.bz2
解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录
```

### [read命令](http://blog.sina.com.cn/s/blog_4077692e0100r7ct.html)

```
read -t 5（设定时间s） -n （设定读取几个字符） -p （输入提示字符）
```

### [shell脚本运算符](http://blog.csdn.net/zhushuai1221/article/details/52526606)