---
layout:     post
title:      "In puts your name here"
subtitle:   " \" just follow the standard way\""
date:       2018-03-06 10:02:52
author:     "朱景泉"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 工作相关
typora-copy-images-to: ../img
---

> “Yeah It's on. ”

MWR DBC 文件解析

```cpp
void processor<T>::DecodeMsg(const T &msg, int Mwr_type)
{
    switch (Mwr_type) {
    case MT_FRONT_ESR:
    {
        MWR_MEASURED_OBJECT rawObj;
        float fThrehloldDeltaSpeed=(0.1*m_pstVCU.get()->fSpeed)>1.0? (0.1*m_pstVCU.get()->fSpeed):1.0;

        int gnTrackPower[64];
        for(int nGroupIndex=0;nGroupIndex<10;nGroupIndex++)
        {
            if(nGroupIndex<9)
            {
                for(int j=0;j<7;j++)
                {
                    gnTrackPower[j+7*nGroupIndex]=(msg.gstCanMsgs[65+nGroupIndex].gbData[1+j]&0x1F)-10;
                }
            }
            else
            {
                gnTrackPower[63]=(msg.gstCanMsgs[65+nGroupIndex].gbData[1]&0x1F)-10;
            }
        }
        int nAngle=0, nRange=0,nRangeRate=0,nLatRate=0,nStatus=0,nWidth;
        float fAngle,fRange,fRangeRate,fLatRate,fWidth;
        for(int i=1;i<65;i++)//0x500~0x53F  注意CANID
        {
            nRange=(msg.gstCanMsgs[i].gbData[2]&0x07)*256+msg.gstCanMsgs[i].gbData[3];
            nStatus=(msg.gstCanMsgs[i].gbData[1]&0xE0)>>5;

            if(nRange<=0)
            {
                continue;
            }

            if(nStatus !=UPDATED_TARGET && nStatus !=COASTED_TARGET)
            {
                rawObj.bIsNoisy=true;
            }
            else
            {
                rawObj.bIsNoisy=false;
            }

            fRange=nRange*0.1;//Range:0~204.7

           //unit::rad;

            nRangeRate=(msg.gstCanMsgs[i].gbData[6]&0x3F)*256+msg.gstCanMsgs[i].gbData[7];

            if(8192==(nRangeRate&8192)) //dec 8192==hex 0x2000
            {
                nRangeRate=nRangeRate-1;
                nRangeRate=~nRangeRate;
                nRangeRate=-(nRangeRate&0x3FFF);
            }

            fRangeRate=nRangeRate*0.01;//speed;-81.92 to 81.91 m/s

            nLatRate=(msg.gstCanMsgs[i].gbData[0]&0xFC)>>2;
            if(32==(nLatRate & 32))
            {
                nLatRate=nLatRate-1;
                nLatRate=~nLatRate;
                nLatRate=-(nLatRate&0x3F);
            }
            fLatRate=-nLatRate*0.25;//Lateral Rate ;-8~7.75m/s;(+)left (-)right

            nWidth=(msg.gstCanMsgs[i].gbData[4]&0x3C)>>2;
            fWidth=nWidth*0.5;//Track Width :0~7.5m

            rawObj.nID=i-1;
            rawObj.fTrackPower=gnTrackPower[i-1];
            rawObj.fRange=fRange;
            rawObj.fRangeRate=fRangeRate;
            rawObj.fWidth=fWidth;
            rawObj.nTimeStamp=msg.stHeader.nTimeStamp;
            rawObj.nSensorType=MT_FRONT_ESR;

            float fDeltaTheta= fAngle;//the delta between vcu vehicle speed and the range rate;
            float fDeltaSpeed=fRangeRate+m_pstVCU.get()->fSpeed*cos(fDeltaTheta);//the object absolute range rate CFI_WORLD

            if(fabs(fDeltaSpeed)>fabs(fThrehloldDeltaSpeed))
            {
                rawObj.bIsObjMoving=true;//object is moving CFI_WORLD
            }
            else
            {
                rawObj.bIsObjMoving=false;
            }

            m_vecRawObjs.push_back(rawObj);
        }
    }
```



![201712272247092](../Pictures/201712272247092.jpg)

```
  int gnTrackPower[64];
        for(int nGroupIndex=0;nGroupIndex<10;nGroupIndex++)
        {
            if(nGroupIndex<9)
            {
                for(int j=0;j<7;j++)
                {
                    gnTrackPower[j+7*nGroupIndex]=(msg.gstCanMsgs[65+nGroupIndex].gbData[1+j]&0x1F)-10;
                }
            }
            else
            {
                gnTrackPower[63]=(msg.gstCanMsgs[65+nGroupIndex].gbData[1]&0x1F)-10;
            }
        }
```

TrackMotionPower 会发送10次（0x0~0x9）一个CAN帧是64bit （8byte），每个CAN帧携带7个Track——power信息，（7*9=63 ，最后一个帧携带一个track_power信息，共63+1=64个track_power）,

每一个track_power的解析

msg.gstCanMsgs[65+nGroupIndex].gbData[1+j]&0x1F)-10;

其中gbData是按每一个byte取，和B00011111进行按位与运算就可以取出真实数据，同时考虑offset-10



![201712272247103](../Downloads/201712272247060.jpg)

![201712272247071](../Downloads/201712272247071.jpg)



```
 nAngle=(msg.gstCanMsgs[i].gbData[1]&0x1F)*32+(msg.gstCanMsgs[i].gbData[2]>>3);
            if((nAngle>>9)==1)
            {
                nAngle=nAngle-1;
                nAngle=~nAngle;
                nAngle=-(nAngle&0x3FF);
            }
            fAngle=-nAngle*0.1*DEGREE_TO_RADIAN;
            
            
 nAngle=(gbData[1]&0x1F)*32+(gbData[2]>>3);(有符号数，首位==1时为负数)（SAIC大端在前）
 -1；取补=～；取反
```

