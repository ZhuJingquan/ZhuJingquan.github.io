---
layout:     post
title:      "日志技巧"
subtitle:   " \" just follow the standard way\""
date:       2018-02-28 11:03:38
author:     "朱景泉"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - ｓｋｉｌｌ
typora-copy-images-to: ../img
---

> “Yeah It's on. ”

- 日志[记录](http://www.infoq.com/cn/articles/why-and-how-log)综述

**1. 对外部的调用封装**

程序中对外部系统与模块的依赖调用前后都记下日志，方便接口调试。出问题时也可以很快理清是哪块的问题

```
1.  LOG.debug("Calling external system:" + parameters);  
2.  Object result = null;  
3.  try {  
4.      result = callRemoteSystem(params);  
5.      LOG.debug("Called successfully. result is " + result);  
6.  } catch (Exception e) {  
7.      LOG.warn("Failed at calling xxx system . exception : " + e);  
8.  }  
```

**2.状态变化**

程序中重要的状态信息的变化应该记录下来，方便查问题时还原现场，推断程序运行过程

```
1.  boolean isRunning;  
2.    
3.  isRunning = true;  
4.  LOG.info("System is running");  
5.    
6.  //...  
7.    
8.  isRunning = false;  
9.  LOG.info("System was interrupted by " + Thread.currentThread().getName());  
```

**3.系统入口与出口：**

这个粒度可以是重要方法级或模块级。记录它的输入与输出，方便定位

```
1.  void execute(Object input) {  
2.      LOG.debug("Invoke parames : " + input);  
3.      Object result = null;  
4.        
5.      //business logic
6.        
7.      LOG.debug("Method result : " + result);  
8.  }  
```

**4.业务异常：**

任何业务异常都应该记下来：

```
1.  try {  
2.      //business logical  
3.  } catch (IOException e) {  
4.      LOG.warn("Description xxx" , e);  
5.  } catch (BusinessException e) {  
6.      LOG.warn("Let me know anything");  
7.  } catch (Exception e) {  
8.      LOG.error("Description xxx", e);  
9.  }  
10.   
```

**5.非预期执行：**

为程序在“有可能”执行到的地方打印日志。如果我想删除一个文件，结果返回成功。但事实上，那个文件在你想删除之前就不存在了。最终结果是一致的，但程序得让我们知道这种情况，要查清为什么文件在删除之前就已经不存在

```
1.  int myValue = xxxx;  
2.  int absResult = Math.abs(myValue);  
3.  if (absResult < 0) {  
4.      LOG.info("Original int " + myValue + "has nagetive abs " + absResult);  
5.  }  
```

**6.很少出现的else情况：**

else可能吞掉你的请求，或是赋予难以理解的最终结果

```
1.  Object result = null;  
2.  if (running) {  
3.     result = xxx;  
4.  } else {  
5.     result = yyy;  
6.     LOG.debug("System does not running, we change the final result");  
7.  }  
```



---

## 程序运行状态可以记哪些？

程序在运行时就像一个机器人，我们可以从它的日志看出它正在做什么，是不是按预期的设计在做，所以这些正常的运行状态是要有的。

**1. 程序运行时间：**

```
1.  long startTime = System.currentTime();  
2.    
3.  // business logical  
4.    
5.  LOG.info("execution cost : " + (System.currentTime() - startTime) + "ms");　  
```

**2. 大批量数据的执行进度：**

```
1.  LOG.debug("current progress: " + (currentPos * 100 / totalAmount) + "%")
```

**3.关键变量及正在做哪些重要的事情：**

执行关键的逻辑，做IO操作等等

```
1.  String getJVMPid() {  
2.     String pid = "";  
3.     // Obtains JVM process ID  
4.     LOG.info("JVM pid is " + pid);  
5.     return pid;  
6.  }  
7.    
8.  void invokeRemoteMethod(Object params) {  
9.      LOG.info("Calling remote method : " + params);  
10.     //Calling remote server  
11. }  
```

## 应该避免怎样的日志方式？

**1. 混淆信息的Log**

日志应该是清晰准确的: 当看到日志的时候，你知道是因为连接池取不到连接导致的问题么？

```
1.  Connection connection = ConnectionFactory.getConnection();  
2.  if (connection == null) {  
3.      LOG.warn("System initialized unsuccessfully");  
4.  }  

```

**2. 记错位置**

产品代码中，使用console记录日志，导致没有找到日志。

```
     1. } catch (ConfigurationException e) {
     2.    e.printStackTrace();
     3. }
```

**3. 记错级别**

记错级别常常发生，常见的如：混淆代码错误和用户错误,如登录系统中，如果恶意登录，那系统内部会出现太多WARN，从而让管理员误以为是代码错误。可以反馈用户以错误，但是不要记录用户错误的行为，除非想达到控制的目的。

```
1.  LOG.warn("Failed to login by "+username+");
```

**4. 遗漏信息**

这里可能包含两种情况：（1）用户自己少写了信息,导致毫无参考价值；（2）用户调用log的方式导致丢失信息，如下例，没有stack trace.

```
     1.  } catch (Exception ex) {
     2.   log.error(ex);
     3.  }
```